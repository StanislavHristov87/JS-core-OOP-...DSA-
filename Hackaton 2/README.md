<img src="https://webassets.telerikacademy.com/images/default-source/logos/telerik-academy.svg" alt="logo" width="300px" style="margin-top: 20px;"/>

# JS Core Hackathon 2

<br>

## Teamwork expectations

Each member of the team must **implement**, **document** and **test** at least 4 functions in `array-utils.js` and be able to explain and fully understand how the entire project works and why it was implemented that way.

<br>

## Description

<br>

### Set up npm project

<br>

**Before you start make sure you have [Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker) installed. Pay attention to spelling errors (they will come with *blue* underlining)**

<br>

- Your task is to implement a utility library. This library is designed with the most popular utility functionalities in mind and can help you throughout the academy.

You have a `Template` folder that contains of several files:

- `array-utils.js` - the library's core - all of the JavaScript utility array methods your team needs to implement.

- `index.js` - here you write the tests of your utils and have 3 big tests that will test all of the functions in `array-utils` and some in-line custom functions working together.

- `package.json` - this is a npm project and you have some dependencies and descriptions here already.

- `eslintrc.json` - eslint configuration to use when setting up the `eslint`

- Run `npm install` to install all the dependencies (command should be run in the same folder where `package.json` is)

- Install eslint and eslint-config-google is as dev dependencies

- Make sure `eslint` is working. You already have the `eslintrc` configuration file.

- Setup `eslint-fix` script to automatically fix problems. Research how `--fix` option of `eslint` works.

- Make sure your repo has a `gitignore` file set up and it ignores the autogenerated files and folders (node_modules, out, etc.) You can go to [gitignore.io](http://gitignore.io/) and see what is suggested for `node` in their templates.

- Document all the `array-utils` functions you write. **Don't forget to author them - put your name to the functions you have implemented.**

  - You can see how the `addFirst` array function is documented. This is a standard approach known as **JSDoc**. Using the following format above a function, describes each of the params and the return type of the function.

    ```js
    /**
     * Add an element at front of the array
     *
     * @author Firstname Lastname <email@domain.com>
     * @param {any} element the element to add
     * @return {addFirstFunc} inner function
     */
    const addFirst = (element) => {
      /**
       * @function addFirstFunc
       * @param {array} array an array to add element into
       * @return {array} a copy of the array with the element added
       */
      return (arr) => [element, ...arr];
    };
    ```

  - Keep in mind that eslint validates that your documentation is correct - if you documented some function to return an array and it doesn't - well you'll get an indication.

  - You could run `npm run doc` to generate the documentation based on these descriptions.
  - After executing the command, open the `out` folder and start the `index.html` file in browser

- Test all the functions you write. **Make sure you author the tests as well.**

  - The tests are in the root `index.js` file, each wrapped in a function that is named after the functionality under test

    ```js
    const addFirstTest = () => {
      const arr = [1, 2, 3];

      const copy = addFirst(5)(arr);

      console.log(arr); // 1, 2, 3
      console.log(copy); // 5, 1, 2, 3
    };
    ```

  - You are given 3 big tests that test integrated functionality. When all of the used functions are ready, they should produce the correct result in the described steps.

<br>

### Ground Rules

- You must implement, document and test at least **4 functions** from `array-utils`
- You are **forbidden** from implementing a function using the same built-in function or a built-in function that can do the same job (implement **indexOf** using built-in **indexOf** or implement **reduce** using **reduceRight**), but you are allowed to use other functions that would solve the same problem, i.e. you can use **reduce** to implement **indexOf**.
- You are **forbidden** from using standard **loops** (for, while, do-while, for-in, for-of)
- Your tools for the hackathon are mostly **higher-order functions**. (map, reduce, find, etc.)
- **_Hint_**: Most of the tasks can be done in a single line expression. Don't feel forced to do it that way if you can't figure it out, but make sure to try it, if you finish earlier with your tasks.

  <br>

### Validations and type guards

You don't need to implement any validations and type guards to ensure correct input. You're implementing a documented utility library - if functions are not used correctly the problem is on the side of the developer not reading the documentation properly. You cannot and should not guard against any possible misuse of your code.

**You don't need to validate arguments**, i.e. when implementing `slice` you don't have to check if `end` is greater than `start` if they are in the array length constraints.

You don't have to make checks for the type of the passed arguments, i.e. if the function expects to receive an array **you don't need to validate** it as shown below:

```js
const reverse = (arr) => {
  // type guard
  if (!Array.isArray(arr)) {
    throw new Error('Not a valid array!');
  }
}
```

<br>

##

# Utility Functions

<br>

We will be using the `TypeScript` type system (the one you see VS Code tooltips in your JavaScript files). Short, but not exhaustive cheat-sheet of TS types:

- `element: any` - variable `element` with dynamic type (can be anything - number, string, boolean, array, function, object, etc.)
- `element: number` - variable `element` is a number
- `element: number | string` - variable `element` can be either number or string
- `element: {}` - variable `element` is any object
- `element: { length: number }` - variable `element` is an object that has a property `length` with its value being a number (may or may not have other properties)
- `arr: any[]` - variable `arr` is an array of dynamic types - the elements can be anything
- `arr: number[]` - variable `arr` is an array of numbers
- `arr: Function[]` - variable `arr` is an array of functions
- `fn: () => any` - variable `fn` is a function with no parameters and can return anything (short is `() => any`)
- `fn: (n: number) => string` - variable `fn` is a function with one parameter `n` (number) and returns a string, (short is `(n: number) => string`)
- `fn: (arr: number[]) => number` - variable `fn` is a function with one parameter `arr` (array of numbers) and returns a number, (short is `(arr: number[]) => number`)

These are only a few of all possible types. Note that VS Code is written in TypeScript and will try to **guess** what are the types of variables you use in your code and provide you with similar tooltips when you hover a variable.

<br>

## `addFirst(element)`

Add an element at the start of the array.

#### Arguments

`element: any`: The element to add.

#### Returns

`(arr: any[]) => any[]`: Returns a closure function that will create a copy of the array with the new element at front.

##

## `removeFirst(arr)`

Removes the first element of the array.

#### Arguments

`arr: any[]`: The array to remove from.

#### Returns

`any[]`: Returns a copy of the array without the removed element.

##

## `addLast(element)`

Add an element at the back of the array.

#### Arguments

`element: any`: The element to add.

#### Returns

`(arr: any[]) => any[]`: Returns a closure function that will create a copy of the array with the new element at back.

##

## `removeLast(arr)`

Removes the last element of the array.

#### Arguments

`arr: any[]`: The array to remove from.

#### Returns

`any[]`: Returns a copy of the array with the removed element.

##

## `keys(arr)`

Get the array's valid indexes.

#### Arguments

`arr: any[]`: The array to get the indexes from.

#### Returns

`number[]`: Returns a new array with the valid indexes.

##

## `entries(arr)`

Get the array's entries in the form of key-value pairs [index, element].

#### Arguments

`arr: any[]`: The array to get the entries from.

#### Returns

`any[]`: Returns a new array with the valid entries in the form [index, element].

**Advanced**: To be strict about the type, we know the function will return an array of arrays of two things - the index of each element of `arr` and the element itself; or an array of `[number, any]` The correct type would be `Array<[number, any]>`, but that is outside the scope of this exercise.

##

## `slice(start, end)`

Creates a copy of an array from the start to the end index.

#### Arguments

`start: number`: The start index to copy from.
`end: number`: The end index to copy to.

#### Returns

`(arr: any[]) => any[]`: Returns a closure that will create a copy of the array from the start to the end index.

##

## `concat(arr)`

Concatenates the elements from one array with the elements of another creating a result array with all the elements.

#### Arguments

`arr: any[]`: The array to concatenate with.

#### Returns

`(innerArr: any[]) => any[]`: Returns a closure that will concatenate the passed inner array with the already received outer.

##

## `reverse(array)` \*

Create a reversed copy of the array so that the first element becomes the last, the second element becomes the second to last, and so on.

#### Arguments

`arr: any[]`:` The array to reverse.

#### Returns

`any[]`: The reversed array.

##

## `join(separator)` \*

Converts all elements in array into a string separated by separator.

#### Arguments

`separator: string`: The element separator.

#### Returns

`(arr: any[]) => string`: Returns a closure that will join the elements of the array with the passed separator.

##

## `find(predicate)` \*

Finds the first element in an array using a predicate function or returns null if it fails.

#### Arguments

`predicate: (el: any, index: number) => boolean`: A function that accepts  an element and (optionally) an index, and returns a boolean value.

#### Returns

`(arr: any[]) => any | null`: Returns a closure that will use the predicate function to find the first element in the array that will return true and returns it. Otherwise return null.

##

## `fill(value, start, end)` \*

Fills elements of array with value from start up to, but not including, end. This should not change the original array.

#### Arguments

`value: any`: The value to fill array with.

`start: number`: The start position.

`end: number`: The end position.

#### Returns

`(arr: any[]) => any[]`: Returns a closure that will fill the passed array with the value.

##

## `forEach(fn)` \*

Call a function with each of the elements of an array as a parameter.

#### Arguments

`fn: (el: any) => void`: The function to call with the elements. (`void` means the `fn` function doesn't return anything, or in the case of JavaScript it implicitly returns **undefined**)

#### Returns

`(arr: any[]) => void`: Returns a closure that will iterate over the passed array and will call the received function with each of the elements. This function does not return anything.

##

## `map(mapperFn)` \*

Transform each of the elements of an array using a mapping function.

#### Arguments

`mapperFn: (el: any) => any`: The mapping function to call with the elements.

#### Returns

`(arr: any[]) => any[]`: Returns a closure that will iterate over the passed array and will call the received mapping function with each of the elements. Collect the results of the mapping function callings and return it as a new array.

##

## `filter(predicate)` \*

Iterates over elements of collection, returning an array of all elements the passed function returns truthy for.

#### Arguments

`predicate: (el: any, index: number) => boolean`: A function that accepts an element and (optionally) an index, and returns a boolean value.

#### Returns

`(arr: any[]) => any[]`: Returns a closure that will iterate over the passed array and will call the received predicate function with each of the elements. Collect all of the elements that the predicate return true for and return it as a new array.

##

## `reduce(fn, initialValue)` \*

Iterates over elements of collection and reducing all of them in a single value.

#### Arguments

`function: (acc: any, el: any) => any`: The reducer function that will accept an accumulator and the next element and will return the updated accumulator.
`initialValue: any`: The accumulator's initial value.

#### Returns

`(arr: any[]) => any`: Returns a closure that will iterate over the passed array and will call the received reducer function with the accumulator variable and the current element. Return the accumulator at the end.

##

## `reduceRight(fn, initialValue)` \*

Iterates over elements of collection backwards and reducing all of them in a single value.

#### Arguments

`function: (acc: any, el: any) => any`: The reducer function that will accept an accumulator and the next element and will return the updated accumulator.
`initialValue: any`: The accumulator's initial value.

#### Returns

`(arr: any[]) => any`: Returns a closure that will iterate over the passed array in reverse order and will call the received reducer function with the accumulator variable and the current element. Return the accumulator at the end.

##

## `some(predicate)` \*

Iterates over elements of a collection and returns true if at least one of them passes the predicate function's condition. Otherwise return false.

#### Arguments

`predicate: (el: any, index: number) => boolean`: A function that accepts an element and (optionally) an index, and returns a boolean value.

#### Returns

`(arr: any[]) => boolean`: Returns a closure that will iterate over the passed array in and will call the received predicate function with each of the elements. If a single one of the calls returns true, return true. Otherwise return false.

##

## `every(predicate)` \*

Iterates over elements of a collection and returns true if all the elements pass the predicate function's condition. Otherwise return false.

#### Arguments

`predicate: (el: any, index: number) => boolean`: A function that accepts an element and (optionally) an index, and returns a boolean value.

#### Returns

`(arr: any[]) => boolean`: Returns a closure that will iterate over the passed array in and will call the received predicate function with each of the elements. If all of the calls return true, return true. Otherwise return false.

##

## `includes(element)` \*

Iterates over elements of a collection and returns true if the searched element is one of them. Otherwise return false.

#### Arguments

`element: any`: The element to search for.

#### Returns

`(arr: any[]) => boolean`: Returns a closure that will iterate over the passed array in and will check if the searched element is there. If its there return true, otherwise return false.

##

## `indexOf(element)` \*

Finds and returns the first index of the searched element in the array. If the element does not exist in the array, return -1.

#### Arguments

`element: any`: The element to search for.

#### Returns

`(arr: any[]) => number`: Returns a closure that will iterate over the passed array in and will check if the searched element is there. If its there return its index, otherwise return -1.If there are more than one occurrences of the element, the index of the first is returned.

##

## `findIndex(predicate)` \*

Finds and returns the index of the searched element in the array based on a predicate function. If the element does not exist in the array, return -1.

#### Arguments

`predicate: (el: any, index: number) => boolean`: A function that accepts an element and (optionally) an index, and returns a boolean value.

#### Returns

`(arr: any[]) => number`: Returns a closure that will iterate over the passed array in and will call the received predicate function with each of the elements. If a call returns true, return the current element's index. Otherwise return -1.

##

## `arrayFrom(obj)` \*\*

Creates an array from object by using its length property.

#### Arguments

`obj: { length: number }`: An object that has the length property.

#### Returns

`undefined[]`: Returns the created array with length equal to the passed object's length property, filled with undefined values.

##

## `pipe(...fns)` \*\*

Accepts any number of functions and creates a sequence where the output of the last function becomes the input for the next.

#### Arguments

`fns: Function[]`: The functions to pipe.

#### Returns

`(input: any) => any`: Returns a closure that will iterate over the passed array of functions and will call the each of them with the output of the last. At the end, return the result of the final one. The input for the first function will be passed as a parameter to the closure.

##

## `compose(...fns)` \*\*

Accepts any number of functions and creates a sequence where the output of the last function becomes the input for the next. It runs trough the functions in reverse order.

#### Arguments

`fns: Function[]`: The functions to compose.

#### Returns

`(input: any) => any`: Returns a closure that will iterate over the passed array of functions and will call the each of them in with the output of the last reverse order. At the end, return the result of the final one. The input for the first (in this case last) function will be passed as a parameter to the closure.

##

## `flat(arr)` \*\*

Create a copy of the array and replace any inner array element with all of its own elements. It goes just one level deep.

#### Arguments

`arr: any[]`: The array to flat.

#### Returns

`any[]`: Returns the flatten array - all of the inner array elements are replaced by their own elements.

##

## `flatMap(mapperFn)` \*\*

Transform each of the elements of an array using a mapping function. The mapping function must always return an array. Flat the array of arrays after the mapping function and return the result.

#### Arguments

`mapperFn: (el: any) => any`: The mapping function. It must return an array.

#### Returns

`(arr: any[]) => any[]`: Returns a closure that will iterate over the passed array and will call the mapping function with each of the elements. Flat the result of the mapping and return it.

##

## `groupBy(groupingFn)` \*\*

Creates an object that will group the array values by a passed grouping function. The object keys will be all of the unique groupings and the values will be an array of the group entries.

#### Arguments

`groupingFn: (el: any) => any`: The grouping function. It will accept an element and return the group identifier.

#### Returns

`(arr: any) => object`: Returns a closure that will iterate over the passed array and will call the grouping function with each of the elements. The grouping function will return the unique group identifier for each of them and this will be the key for the result object. The values will be arrays of the group members.

Example:

```js
const people = [
  { age: 20, name: 'Pesho' },
  { age: 24, name: 'Gosho' },
  { age: 23, name: 'Dessy' },
  { age: 24, name: 'Gerry' },
];

const result = groupBy(person => person.age)(people):

/*
{
  '20': [
    {
      age: 20,
      name: 'Pesho'
    }
  ],
  '23': [
    {
      age: 23,
      name: 'Dessy'
    }
  ],
  '24': [
    {
      age: 24,
      name: 'Gosho'
    },
    {
      age: 24,
      name: 'Gerry'
    }
  ]
}
*/
```
